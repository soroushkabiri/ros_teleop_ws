#!/usr/bin/env python3
import math
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu
from std_msgs.msg import Float32
import numpy as np
from nav_msgs.msg import Path, Odometry
from geometry_msgs.msg import PointStamped, Twist
from rcl_interfaces.msg import SetParametersResult
from std_msgs.msg import String , Bool


def angle_wrap(a):
    """Wrap angle to [-pi, pi]."""
    return (a + np.pi) % (2 * np.pi) - np.pi

def Rec_mem(a,b,c,d):
    if a==0:
        if d<=b:
            e=1
        elif d>b and d<=b+c:
            e=1-(d-b)*(1/c)
        else :
            e=0
    elif a==1:
        if d<=b-c:
            e=0
        elif d>b-c and d<=b:
            e=(d-b+c)*(1/c)
        elif d>b and d<=b+c:
            e=1-(d-b)*(1/c)
        else :
            e=0
    else :  
        if d<=b-c:
            e=0
        elif d>b-c and d<=b:
            e=(d-b+c)*(1/c)
        else :
            e=1
    return e

class FuzzyPathPlanner(Node):
    def __init__(self, num_waypoints=1000,waypoint_tolerance=0.4):
        super().__init__('fuzzy_planner')

        # the variable to set how many followers i have.
        self.followers_number = '1'  
        # Subscribe to /followers_number to know when the process should begin
        self.create_subscription(String, '/followers_number', self.followers_number_callback, 10)
    
        self.planner_type='fuzzy'

        # Subscriptions
        self.create_subscription(Path, '/rtabmap/global_path', self.plan_callback, 10)
        self.create_subscription(Odometry, '/rtabmap/odom', self.odom_callback, 10)
        self.create_subscription(PointStamped, '/closest_obstacle_in_range', self.closest_obstacle_callback, 10)
        self.create_subscription(Float32, '/robot0_0/yaw_deg', self.yaw_callback, 10)

        # Publisher for fuzzy cmd_vel
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel_fuzzy', 10)

        # Timer to update waypoint following
        self.create_timer(0.5, self.follow_waypoints)
        self.dt = 0.1  # 10 Hz control loop
        self.create_timer(self.dt, self.control_loop)

        self.theta = 0.0  # current heading in radians
        # catch waypoints of the static path generated by nav2
        self.num_waypoints = num_waypoints
        # the parameter that determine when the code go to the next waypoint
        self.waypoint_tolerance = waypoint_tolerance
        self.current_wp_index = 0
        self.waypoints = None  # Will be a numpy array of shape (N, 2)
        self.ended_goal = True  # <--- NEW flag, start as ended (no goal yet)


        # get rect_obj position and velocity from odom topic 
        self.rect_obj_position=np.array([0,0]).reshape(1,2)
        self.rect_obj_velocity=np.array([0,0]).reshape(1,2)

        # current way point that is a single part of waypoints array that changes while the robot moves
        self.current_way_point=np.array([0,0]).reshape(1,2)
                
        # array in the shape of (num obs,2)
        # get the position and velocity of closest obstacle from closest_obstacle_in_range topic
        self.position_obstacles=np.array([10,0]).reshape(1,2)
        self.velocity_obstacles=np.array([0,0]).reshape(1,2)

        # Declare parameters with defaults
        self.declare_parameter("attractive_fuzzy_const",30.0)
        self.declare_parameter('repulsive_fuzzy_const',25.0)
        
        self.declare_parameter("k_att", 5.0)
        self.declare_parameter("r_safe_min", 2.5)
        self.declare_parameter("k_rep_p", 20.0)
        self.declare_parameter("k_rep_v", 20.0)


        # Load parameter values
        self.attractive_fuzzy_const=self.get_parameter("attractive_fuzzy_const").value
        self.repulsive_fuzzy_const=self.get_parameter('repulsive_fuzzy_const').value

        self.k_att = self.get_parameter("k_att").value
        self.r_safe_min = self.get_parameter("r_safe_min").value
        self.k_rep_p = self.get_parameter("k_rep_p").value
        self.k_rep_v = self.get_parameter("k_rep_v").value

        # Add callback to update when params change
        self.add_on_set_parameters_callback(self.parameter_callback)

        self.max_v_leader=0.2
        self.max_omega_leader=0.4

        # Constants for r_safe calculation (these are find experimentally and should be improved)
        self.kv = 2
        self.ka = 1

    def followers_number_callback(self, msg):
        self.followers_number = msg.data   # store the string ("1" or "2")

    def plan_callback(self, msg: Path):
        """Catch static path waypoints from Nav2 once."""
        #if self.waypoints is not None and self.current_wp_index < len(self.waypoints):
        #    return
        if not self.ended_goal:
            # Already following a path â†’ ignore until finished
            return
        
        total = len(msg.poses)
        if total == 0:
            self.get_logger().warn("Received empty path!")
            return

        # Downsample waypoints
        step = max(1, total // self.num_waypoints)
        points = [
            (msg.poses[i].pose.position.x, msg.poses[i].pose.position.y)
            for i in range(0, total, step)
        ][:self.num_waypoints]

        self.waypoints = np.array(points)
        self.current_wp_index = 0
        self.current_way_point = self.waypoints[0].reshape(1, 2)
        self.ended_goal = False   # ðŸš€ New goal started

        self.get_logger().info(f"Received {total} poses â†’ reduced to {self.waypoints.shape[0]} waypoints.")

    def follow_waypoints(self):
        """Update current waypoint based on proximity."""
        if self.waypoints is None:
            return
        if self.current_wp_index >= len(self.waypoints):
            self.get_logger().info("Reached final waypoint.")
            self.ended_goal = True   # ðŸš© Mark goal as finished
            #self.current_wp_index=0
            return

        goal_position = self.waypoints[self.current_wp_index].reshape(1, 2)
        self.current_way_point = goal_position
        # Distance to current goal
        dist = np.linalg.norm(self.rect_obj_position - goal_position)
        # Move to next waypoint if close enough
        if dist <= self.waypoint_tolerance:
            self.current_wp_index += 1


    def fuzzy_planner(self):
        # Calculate attractive and repulsive force
        if self.planner_type=='apf':
            F_att = self.attractive_part_apf()
            F_rep=self.repulsive_part_apf()
        elif self.planner_type=='fuzzy':
            F_att=self.attractive_potential_fuzzy()
            F_rep=self.dynamic_repulsive_potential_fuzzy()
        # Total force
        F_total = F_att + F_rep
        # Convert resultant force to velocity commands
        theta_d = np.arctan2(F_total[0][1], F_total[0][0])  # Desired heading angle. this is the angle of potential field force
        v_d = 1*(F_total / 20) # 20 is the number that have reached experimentally (need to be work on)
        #self.get_logger().info(f"F_totalâ†’ F_total={np.linalg.norm(F_total)} ")
        # Limit linear velocity
        if np.linalg.norm(v_d) > self.max_v_leader:
            v_d = (v_d / np.linalg.norm(v_d)) * self.max_v_leader
        v_d =1* np.linalg.norm(v_d)
        # Angular velocity based on yaw error
        kp=10.5 #proportional gain
        diff = ((self.theta - theta_d + math.pi) % (2*math.pi)) - math.pi
        angular_z = kp * diff
        omega_d = np.sign(angular_z) * min(abs(angular_z), self.max_omega_leader)
        #self.get_logger().info(f" theta_d = {np.rad2deg(theta_d):.1f}, theta = {np.rad2deg(self.theta):.1f} Â°")
        return v_d, -omega_d 
    
    def control_loop(self):
        # Update waypoint
        self.follow_waypoints()
        # If no path loaded yet, don't command motion
        if self.waypoints is None or self.current_wp_index >= (len(self.waypoints) if self.waypoints is not None else 0):
            twist = Twist()
            self.cmd_pub.publish(twist)
            return

        # Run fuzzy planner
        v_d, omega_d = self.fuzzy_planner()

        # Publish ABSOLUTE values (per your request) for a differential drive:
        twist = Twist()
        twist.linear.x  = float((v_d))
        twist.angular.z = float((omega_d))
        # Ensure diff-drive compliant fields:
        twist.linear.y = 0.0
        twist.linear.z = 0.0
        twist.angular.x = 0.0
        twist.angular.y = 0.0
        self.cmd_pub.publish(twist)
        # Optional: brief debug
        self.get_logger().info(f"cmd_vel_fuzzy â†’ v={twist.linear.x:.2f} m/s, Ï‰={twist.angular.z:.2f} rad/s")


    def parameter_callback(self, params):
        """Handle runtime parameter updates; accept numeric values for these params."""
        ok = True
        bad_params = []
        for param in params:
            try:
                if param.name == "k_att":
                    self.k_att = float(param.value)
                elif param.name == "r_safe_min":
                    self.r_safe_min = float(param.value)
                elif param.name == "k_rep_p":
                    self.k_rep_p = float(param.value)
                elif param.name == "k_rep_v":
                    self.k_rep_v = float(param.value)
                elif param.name == "attractive_fuzzy_const":
                    self.attractive_fuzzy_const = float(param.value)
                elif param.name==  'repulsive_fuzzy_const':
                    self.repulsive_fuzzy_const=float(param.value)

                # if you later add non-numeric params, handle them here
            except (TypeError, ValueError):
                ok = False
                bad_params.append(param.name)
        if ok:
            self.get_logger().info(
                f"Updated params â†’ attractive_fuzzy_const={self.attractive_fuzzy_const},")
            return SetParametersResult(successful=True)
        else:
            reason = f"Invalid (non-numeric) value for: {', '.join(bad_params)}"
            self.get_logger().warning(reason)
            return SetParametersResult(successful=False, reason=reason)
        


        
    def odom_callback(self, msg: Odometry):
        """Update robot position and velocity from odometry."""
        x = msg.pose.pose.position.x
        y = msg.pose.pose.position.y
        self.rect_obj_position = np.array([x, y]).reshape(1, 2)

        vx = msg.twist.twist.linear.x
        vy = msg.twist.twist.linear.y
        self.rect_obj_velocity = np.array([vx, vy]).reshape(1, 2)
        #self.get_logger().info(f"/rtabmap/odom received â†’ position=({x:.2f}, {y:.2f}))")

    def closest_obstacle_callback(self, msg: PointStamped):
        """Update closest obstacle position (velocity left as 0)."""
        x = msg.point.x
        y = msg.point.y
        self.position_obstacles = np.array([x, y]).reshape(1, 2)

    def yaw_callback(self, msg: Float32):
        # Convert degrees â†’ radians
        self.theta = np.deg2rad(msg.data)

    def attractive_potential_fuzzy(self):
        n_1=8
        diff = self.rect_obj_position - self.current_way_point
        c_1=(0.5-0)/(n_1-1)
        #c_1=(3-0)/(n_1-1)
        R_1=[0,0.5,0.9,0.9,0.9,0.9,0.95,1]
        a=0
        b=0
        for jj in range(n_1):
            if jj==0:
                a=a+Rec_mem(0,0+jj*c_1,c_1,np.linalg.norm(diff))
                b=b+R_1[jj]*Rec_mem(0,0+jj*c_1,c_1,np.linalg.norm(diff))
            elif jj>0 and jj<n_1-1:
                a=a+Rec_mem(1,0+jj*c_1,c_1,np.linalg.norm(diff))
                b=b+R_1[jj]*Rec_mem(1,0+jj*c_1,c_1,np.linalg.norm(diff))
            else :
                a=a+Rec_mem(2,0+jj*c_1,c_1,np.linalg.norm(diff))
                b=b+R_1[jj]*Rec_mem(2,0+jj*c_1,c_1,np.linalg.norm(diff))
        d_1=b/a
        F_att = -d_1*diff*13*self.max_v_leader/np.linalg.norm(diff) # Attractive force vector
        return F_att

    def dynamic_repulsive_potential_fuzzy(self):
        
        num_obs=self.position_obstacles.shape[0] # Number of obstacles
        position_obs=self.position_obstacles
        velocity_obs=self.velocity_obstacles
        # Initialize repulsive forces
        F_rep_p = np.array([np.zeros(2, dtype=np.float64)])
        F_rep_v = np.array([np.zeros(2, dtype=np.float64)])

        for i in range(num_obs): # in this loop we will be calculating cos_delta and threat level to use in repulsive potential
            # Calculate relative position and velocity
            p_relative = position_obs[i] - self.rect_obj_position
            velocity_relative = self.rect_obj_velocity - velocity_obs[i]

            # Calculate distance to obstacle
            dist_relative = np.linalg.norm(p_relative)

            # Calculate angle between relative position and relative velocity. this angle shows us that the obstacle and our object will be colliding or not. if cos_delta>0
            # then they will be colliding 
            if dist_relative == 0 or np.linalg.norm(velocity_relative) == 0:
                cos_delta = 0.0
            else:
                cos_delta = np.dot(p_relative, velocity_relative.T) / (dist_relative * np.linalg.norm(velocity_relative))
            delta = np.arccos(np.clip(cos_delta, -1, 1))

            # Calculate variable safety radius. the safety radius is the measure that act as on off switch in repulsive force calculation. r_safe=r_min_safe+r_var_safe
            #r_min_p=2.5
            #r_min_p=1.25+rectangular_object_property["length"]*(math.sqrt(2)/2)

            #r_min_p=0.8
            #r_activate_p=2
            r_min_p=1.0
            r_activate_p=1.2

            #r_activate_p=6
            #r_activate_p=5+rectangular_object_property["length"]*(math.sqrt(2)/2)

            d_2=0
            if dist_relative<=r_activate_p:
                n_2=10
                a=0
                b=0  
                c_2=(r_activate_p-r_min_p)/(n_2-1)
                R_2=[100,40,1,0.9,0.7,0.5,0.4,0.2,0.1,0]
                a=0
                b=0

                for jj in range(n_2):
                    if jj==0:
                        a=a+Rec_mem(0,r_min_p+jj*c_2,c_2,np.linalg.norm(dist_relative))
                        b=b+R_2[jj]*Rec_mem(0,r_min_p+jj*c_2,c_2,np.linalg.norm(dist_relative))
                    elif jj>0 and jj<n_2-1:
                        a=a+Rec_mem(1,r_min_p+jj*c_2,c_2,np.linalg.norm(dist_relative))
                        b=b+R_2[jj]*Rec_mem(1,r_min_p+jj*c_2,c_2,np.linalg.norm(dist_relative))
                    else :
                        a=a+Rec_mem(2,r_min_p+jj*c_2,c_2,np.linalg.norm(dist_relative))
                        b=b+R_2[jj]*Rec_mem(2,r_min_p+jj*c_2,c_2,np.linalg.norm(dist_relative))
                d_2=b/a

            #r_min_v=3
            #r_min_v=1.5+rectangular_object_property["length"]*(math.sqrt(2)/2)
            #r_activate_v=7+rectangular_object_property["length"]*(math.sqrt(2)/2)
            #r_min_v=0.8
            #r_activate_v=3.5
            r_min_v=0.2
            r_activate_v=1.0

            
            #r_activate_v=10
            d_1=0
            if dist_relative<=r_activate_v:
                n_1=10
                c_1=(r_activate_v-r_min_v)/(n_1-1)
                R_1=[1,0.9,0.8,0.75,0.7,0.65,0.6,0.5,0.3,0]
                a=0
                b=0
                for jj in range(n_1):
                    if jj==0:
                        a=a+Rec_mem(0,r_min_v+jj*c_1,c_1,dist_relative)
                        b=b+R_1[jj]*Rec_mem(0,r_min_v+jj*c_1,c_1,dist_relative)
                    elif jj>0 and jj<n_1-1:
                        a=a+Rec_mem(1,r_min_v+jj*c_1,c_1,dist_relative)
                        b=b+R_1[jj]*Rec_mem(1,r_min_v+jj*c_1,c_1,dist_relative)
                    else :
                        a=a+Rec_mem(2,r_min_v+jj*c_1,c_1,dist_relative)
                        b=b+R_1[jj]*Rec_mem(2,r_min_v+jj*c_1,c_1,dist_relative)
                d_1=b/a
                a=0
                b=0
                n_4=7
                n_5=7
                #c_4=(3)/(n_4-1)
                #c_4=(max_velocity_robot+max_velocity_obstacle)/(n_4-1)
                c_4=(self.max_v_leader+0)/(n_4-1)

                c_5=(1)/(n_5-1)
                aa=np.linalg.norm(velocity_relative)
                R_3=np.array([[0,0,0,0,0,0,0],[0+0.02,0.05,0.1,0.13,0.2,0.25,0.3],[0+0.02,0.07,0.15,0.17,0.3,0.35,0.5],[0+0.02,0.13,0.2,0.35,0.55,0.6,0.7],
                            [0+0.02,0.2,0.3,0.6,0.65,0.8,0.9],[0+0.02,0.3,0.5,0.75,0.85,0.93,1],[0+0.02,0.4,0.6,0.80,0.93,0.96,1]])
                for jj in range(n_4):
                    for kk in range(n_5):
                        if jj==0:
                            if kk==0:
                                a=a+Rec_mem(0,0+jj*c_4,c_4,aa)*Rec_mem(0,kk*c_5,c_5,cos_delta)
                                b=b+R_3[jj][kk]*Rec_mem(0,0+jj*c_4,c_4,aa)*Rec_mem(0,kk*c_5,c_5,cos_delta)
                            elif kk>0 and kk<n_5-1:
                                a=a+Rec_mem(0,0+jj*c_4,c_4,aa)*Rec_mem(1,kk*c_5,c_5,cos_delta)
                                b=b+R_3[jj][kk]*Rec_mem(0,0+jj*c_4,c_4,aa)*Rec_mem(1,kk*c_5,c_5,cos_delta)
                            else :
                                a=a+Rec_mem(0,0+jj*c_4,c_4,aa)*Rec_mem(2,kk*c_5,c_5,cos_delta)
                                b=b+R_3[jj][kk]*Rec_mem(0,0+jj*c_4,c_4,aa)*Rec_mem(2,kk*c_5,c_5,cos_delta)
                        elif jj>0 and jj<n_4-1:
                            if kk==0:
                                a=a+Rec_mem(1,0+jj*c_4,c_4,aa)*Rec_mem(0,kk*c_5,c_5,cos_delta)
                                b=b+R_3[jj][kk]*Rec_mem(1,0+jj*c_4,c_4,aa)*Rec_mem(0,kk*c_5,c_5,cos_delta)
                            elif kk>0 and kk<n_5-1:
                                a=a+Rec_mem(1,0+jj*c_4,c_4,aa)*Rec_mem(1,kk*c_5,c_5,cos_delta)
                                b=b+R_3[jj][kk]*Rec_mem(1,0+jj*c_4,c_4,aa)*Rec_mem(1,kk*c_5,c_5,cos_delta)
                            else :
                                a=a+Rec_mem(1,0+jj*c_4,c_4,aa)*Rec_mem(2,kk*c_5,c_5,cos_delta)
                                b=b+R_3[jj][kk]*Rec_mem(1,0+jj*c_4,c_4,aa)*Rec_mem(2,kk*c_5,c_5,cos_delta)
                        else :
                            if kk==0:
                                a=a+Rec_mem(2,0+jj*c_4,c_4,aa)*Rec_mem(0,kk*c_5,c_5,cos_delta)
                                b=b+R_3[jj][kk]*Rec_mem(2,0+jj*c_4,c_4,aa)*Rec_mem(0,kk*c_5,c_5,cos_delta)
                            elif kk>0 and kk<n_5-1:
                                a=a+Rec_mem(2,0+jj*c_4,c_4,aa)*Rec_mem(1,kk*c_5,c_5,cos_delta)
                                b=b+R_3[jj][kk]*Rec_mem(2,0+jj*c_4,c_4,aa)*Rec_mem(1,kk*c_5,c_5,cos_delta)
                            else :
                                a=a+Rec_mem(2,0+jj*c_4,c_4,aa)*Rec_mem(2,kk*c_5,c_5,cos_delta)
                                b=b+R_3[jj][kk]*Rec_mem(2,0+jj*c_4,c_4,aa)*Rec_mem(2,kk*c_5,c_5,cos_delta)
                d_1=b/a*d_1
                #if i<num_obs-num_obstacle_static:
                #    if np.linalg.norm(dist_relative)>1e-2:
                #        F_rep_p +=(-p_relative / dist_relative)*d_2
                #        #normal_vector = np.array([-p_relative[0,1], p_relative[0,0]])  # 2D version
                #        # Normalize the normal vector
                #        #unit_normal = normal_vector / np.linalg.norm(normal_vector)
                #        #F_rep_p += unit_normal * d_2 * 0.3



                #    if np.linalg.norm(velocity_relative)>1e-2:
                #        F_rep_v +=(velocity_relative/np.linalg.norm(velocity_relative))*d_1


                #        normal_vector = np.array([-velocity_relative[0,1], velocity_relative[0,0]])  # 2D version
                #        # Normalize the normal vector
                #        unit_normal = normal_vector / np.linalg.norm(normal_vector)
                #        F_rep_v += unit_normal * d_1 * 0.1

                #else:
                #    F_rep_p +=(-p_relative / dist_relative)*d_2*1# we improvised this with a constant so effect of static obstacle be less
                #    if np.linalg.norm(velocity_relative)>1e-2:
                #        F_rep_v +=(velocity_relative/np.linalg.norm(velocity_relative))*d_1*1 # we improvised this with a constant so effect of static obstacle be less
                #        normal_vector = np.array([-velocity_relative[0,1], velocity_relative[0,0]])  # 2D version
                #        # Normalize the normal vector
                #        unit_normal = normal_vector / np.linalg.norm(normal_vector)
                #        F_rep_v += unit_normal * d_1 * 0.2


                F_rep_p +=(-p_relative / dist_relative)*d_2*1# we improvised this with a constant so effect of static obstacle be less
                if np.linalg.norm(velocity_relative)>1e-2:
                    F_rep_v +=(velocity_relative/np.linalg.norm(velocity_relative))*d_1*1 # we improvised this with a constant so effect of static obstacle be less
                    normal_vector = np.array([-velocity_relative[0,1], velocity_relative[0,0]])  # 2D version
                    # Normalize the normal vector
                    unit_normal = normal_vector / np.linalg.norm(normal_vector)
                    F_rep_v += unit_normal * d_1 * 0.2
        #F_t =40*F_rep_p+10*F_rep_v
        #F_t =25*F_rep_p+16*F_rep_v
        #F_t =5*F_rep_p+0*F_rep_v
        F_t =self.repulsive_fuzzy_const*F_rep_p+0*F_rep_v


        return F_t


def main(args=None):
    rclpy.init(args=args)
    node = FuzzyPathPlanner(num_waypoints=4, waypoint_tolerance=0.3)  
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()

#ros2 topic pub /rtabmap/goal geometry_msgs/PoseStamped "{header: {frame_id: 'map'}, pose: {position: {x: 1.5, y: 0.0, z: 0.0}, orientation: {w: 1.0}}}"

